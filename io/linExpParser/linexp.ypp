%{
#include <cstdio>
#include <cstring>
#include <vector>

#include "application/DataStructureDirections.h"
#include "core/HybridAutomata/Hybrid_Automata.h"
#include "core/continuous/Polytope/polytope.h"

extern int linexplex();
extern int linexperror(char *);

polytope::ptr global_p; // initial_polytope

extern hybrid_automata ha; // gives access to index to id map.
std::vector<double> l_coeff, r_coeff;
extern std::vector<double> coeff, u_coeff;

double lconstant = 0, rconstant = 0, bound = 0;
%}

%union{ char* token_str; double const_val;}
%token VAR UVAR CONST PLUS MULT EQ LEQ GEQ
%type <token_str> VAR UVAR
%type <const_val> CONST
%start S
 
%%

S : LExpr EQ RExpr				{
														// consider as <=
														int n = ha.map_size();
														coeff.clear();
														coeff.resize(n,0);
														for(unsigned int i=0;i<n;i++)
														{
															if(!l_coeff.empty() && l_coeff[i]!=0)
																coeff[i] = l_coeff[i];
															else if(!r_coeff.empty() && r_coeff[i]!=0)
																coeff[i] = -r_coeff[i];
														}
														bound = rconstant - lconstant;
														global_p->setMoreConstraints(coeff, bound);
														/*std::cout << "EQ constraint(<=):\n";
														for(unsigned int i=0;i<n;i++)
															std::cout << coeff[i] << " ";
														
														std::cout << "\nbound = " << bound << std::endl;
														*/	
														// consider as >=
														coeff.clear();
														coeff.resize(n,0);
														for(unsigned int i=0;i<n;i++)
														{
															if(!l_coeff.empty() && l_coeff[i]!=0)
																coeff[i] = -l_coeff[i];
															else if(!r_coeff.empty() && r_coeff[i]!=0)
																coeff[i] = r_coeff[i];
														}
														bound =  lconstant - rconstant;
														global_p->setMoreConstraints(coeff, bound);
														/*
														std::cout << "EQ constraint (>=):\n";
														for(unsigned int i=0;i<n;i++)
															std::cout << coeff[i] << " ";
														std::cout << "\nbound = " << bound << std::endl;
														*/
														rconstant = 0; lconstant=0;
														l_coeff.clear(); r_coeff.clear();
														return 0;
													}
	| LExpr LEQ RExpr 			{
														int n = ha.map_size();
														coeff.clear();
														coeff.resize(n,0);
														for(unsigned int i=0;i<n;i++)
														{
															if(!l_coeff.empty() && l_coeff[i]!=0)
																coeff[i] = l_coeff[i];
															else if(!r_coeff.empty() && r_coeff[i]!=0)
																coeff[i] = -r_coeff[i];
														}
														bound = rconstant - lconstant;
														global_p->setMoreConstraints(coeff, bound);
														rconstant = 0; lconstant=0;
														l_coeff.clear(); r_coeff.clear();
														/*
														std::cout << "leq constraint:\n";
														for(unsigned int i=0;i<n;i++)
															std::cout << coeff[i] << " " ;
														std::cout << "\nbound = " << bound << std::endl;
														*/
														return 0; 
													}
	| LExpr GEQ RExpr				{
														int n = ha.map_size();
														coeff.clear();
														coeff.resize(n,0);
														for(unsigned int i=0;i<n;i++)
														{
															if(!l_coeff.empty() && l_coeff[i]!=0)
																coeff[i] = -l_coeff[i];
															else if(!r_coeff.empty() && r_coeff[i]!=0)
																coeff[i] = r_coeff[i];
														}
														bound = lconstant - rconstant;
														global_p->setMoreConstraints(coeff, bound);

														rconstant = 0; lconstant=0;
														l_coeff.clear(); r_coeff.clear();
														return 0;
													}
	;	

LExpr : LExpr PLUS LExpr  	{;}
		 | VAR					  	{										
													std::string var = $1;
													int id = ha.get_index(var);
													if(l_coeff.empty()) 
														l_coeff.resize(ha.map_size(),0);
													l_coeff[id]=1;
												}
		 | UVAR							{
												}
		 | CONST 						{
													lconstant = $1; 
												}
		 | CONST MULT UVAR	{
													std::string uvar = $3;
													int id = ha.get_u_index(uvar);
													double c = $1;
													if(u_coeff.empty())
														u_coeff.resize(ha.umap_size(),0);
													u_coeff[id] = c;
												}
		 | UVAR MULT CONST	{
													std::string uvar = $1;
													int id = ha.get_u_index(uvar);
													double c = $3;
													if(u_coeff.empty()) 
														u_coeff.resize(ha.umap_size(),0);						
													u_coeff[id] = c;
												}
		 | CONST MULT VAR		{
													std::string var = $3;
													int id = ha.get_index(var);
													double c = $1;
													if(l_coeff.empty()) 
														l_coeff.resize(ha.map_size(),0);						
													l_coeff[id] = c; 	
												}
		 | VAR MULT CONST		{
													std::string var = $1;
													int id = ha.get_index(var);
													double c = $3;
													if(l_coeff.empty()) 
														l_coeff.resize(ha.map_size(),0);						
													l_coeff[id] = c;	
												}
		 | CONST VAR				{
													std::string var = $2;
													int id = ha.get_index(var);
													double c = $1;
													if(l_coeff.empty()) 
														l_coeff.resize(ha.map_size(),0);						
													l_coeff[id] = c; 								
												}
		 | CONST UVAR				{
													std::string uvar = $2;
													int id = ha.get_u_index(uvar);
													double c = $1;
													if(u_coeff.empty()) 
														u_coeff.resize(ha.umap_size(),0);						
													u_coeff[id] = c; 								
												}
		 ;

RExpr : RExpr PLUS RExpr {;}
		 | VAR					  	{										
													std::string var = $1;
													int id = ha.get_index(var);
													if(r_coeff.empty()) 
														r_coeff.resize(ha.map_size(),0);
													r_coeff[id]=1;
												}
		 | UVAR							{
												}
		 | CONST 						{
													rconstant = $1; 
												}
		 | CONST MULT UVAR	{
													std::string uvar = $3;
													int id = ha.get_u_index(uvar);
													double c = $1;
													if(u_coeff.empty())
														u_coeff.resize(ha.umap_size(),0);
													u_coeff[id] = c;
												}
		 | UVAR MULT CONST	{
													std::string uvar = $1;
													int id = ha.get_u_index(uvar);
													double c = $3;
													if(u_coeff.empty()) 
														u_coeff.resize(ha.umap_size(),0);						
													u_coeff[id] = c;
												}
		 | CONST MULT VAR		{
													std::string var = $3;
													int id = ha.get_index(var);
													double c = $1;
													if(r_coeff.empty()) 
														r_coeff.resize(ha.map_size(),0);						
													r_coeff[id] = c; 	
												}
		 | VAR MULT CONST		{
													std::string var = $1;
													int id = ha.get_index(var);
													double c = $3;
													if(r_coeff.empty()) 
														r_coeff.resize(ha.map_size(),0);						
													r_coeff[id] = c;	
												}
		 | CONST VAR				{
													std::string var = $2;
													int id = ha.get_index(var);
													double c = $1;
													if(r_coeff.empty()) 
														r_coeff.resize(ha.map_size(),0);						
													r_coeff[id] = c; 								
												}
		 | CONST UVAR				{
													std::string uvar = $2;
													int id = ha.get_u_index(uvar);
													double c = $1;
													if(u_coeff.empty()) 
														u_coeff.resize(ha.umap_size(),0);						
													u_coeff[id] = c; 								
												}
		 ;
%%

void linexp_parser(polytope::ptr& p)
{
	global_p = p;
	linexpparse();
	p = global_p;
}
int linexperror(char* s)
{
	fprintf(stderr,"Linear Constraint Expression Specification: %s\n", s);
	return 0;
}

